-- Тип, являющиеся множествами, ведут себя как множества в теории множеств.
-- Это означает, что многие теоремы из нее можно доказать и в теории типов.
-- Например, мы можем доказать теорему Кантора, которая говорит, что мощность множества X строго меньше, чем мощность множества его подмножеств, то есть множества X -> \Prop.

-- Тот факт, что мощность меньше, означает, что существует инъекция из X в X -> \Prop.
-- В качестве такой инъекции мы можем просто взять предикат равенства.
-- (=) : X -> (X -> \Prop)

-- Тот факт, что мощность строго меньше, означает, что не существует сюръекции вида
-- f : X -> (X -> \Prop)
-- Это легко доказать так же как и в классическом случае.

-- Некоторые факты невозможно доказать в теории типов, так как мы не предполагаем закон исключенного третьего или аксиому выбора.
-- Например, теорема Кантора-Бернштейна, которая говорит, что если одно множество вкладывается в другое, и наоборот, то между ними есть биекция, не доказуема без исключенного третьего.
-- При необходимости мы можем добавить эти классические принципы.
-- Тогда теория станет еще больше похожа на классическую теорию множеств.

-- 1. Сюръективные функции.

\func isInj {A B : \Type} (f : A -> B) => \Pi (x y : A) -> f x = f y -> x = y

\truncated \data Trunc (A : \Type) : \Prop
  | in A

-- Сюръективные функции определяютя очевидным образом.
-- Обратите внимание, что мы используем обрезание, так как хотим, чтобы этот тип был утверждением.
\func isSur {A B : \Type} (f : A -> B) : \Prop =>
  \Pi (y : B) -> Trunc (\Sigma (x : A) (f x = y))

-- 2. Лемма про факторизацию.

-- Мы докажем следующее утверждение:
-- f : A -> B => exists g : A -> C, h : C -> B, h `o` g = f, isSur g, isInj h
-- Другими словами, для любой функции f : A -> B существует ее факторизация в сюръекцию g : A -> C и инъекцию h : C -> B.
-- Факторизация означает, что композиция этих двух функций равна f.

\func idp {A : \Type} {a : A} => path (\lam _ => a)

\func J
  {A : \Type} {a : A}
  (B : \Pi (a' : A) -> a = a' -> \Type)
  (b : B a idp)
  {a' : A} (p : a = a')
  : B a' p
  => coe (\lam i => B (p @ i) (psqueeze p i)) b right
  \where {
    \func squeeze (i j : I) => coe (\lam i => Path (\lam j => left = squeeze1 i j) (path (\lam _ => left)) (path (\lam j => squeeze1 i j))) (path (\lam _ => path (\lam _ => left))) right @ i @ j
    \func squeeze1 (i j : I) => coe (\lam x => left = x) (path (\lam _ => left)) j @ i
    \func psqueeze {A : \Type} {a a' : A} (p : a = a') (i : I) : a = p @ i => path (\lam j => p @ squeeze i j)
  }

\func pmap {A B : \Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' =>
  path (\lam i => f (p @ i))

\func transport {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) : B a' =>
  coe (\lam i => B (p @ i)) b right

-- Чтобы доказать, что пары, вторые компоненты которых являются утверждениями, равны, достаточно доказать, что равны их первые компоненты.
\func sigmaInc {A : \Type} (B : A -> \Prop) (t1 t2 : \Sigma (x : A) (B x)) (p : t1.1 = t2.1) : t1 = t2
  => J (\lam a' p' => \Pi (b' : B a') (q' : transport B p' t1.2 = b') -> t1 = (a',b'))
       (\lam b' q' => pmap (\lam b'' => ((t1.1,b'') : \Sigma (x : A) (B x))) q')
       p t2.2 (Path.inProp _ _)

-- Тип C -- это просто образ функции f.
-- Функции g и h определяются очевидным образом.
\func factorization {A B : \Set} (f : A -> B)
  : \Sigma (C : \Set) (g : A -> C) (h : C -> B) (\Pi (x : A) -> h (g x) = f x) (isSur g) (isInj h)
  => (\Sigma (b : B) (Trunc (\Sigma (a : A) (f a = b))),
      \lam a => (f a, in (a, idp)),
      \lam p => p.1,
      \lam a => idp,
      \lam p => \case p.2 \with { | in q => in (q.1, sigmaInc (\lam b => Trunc (\Sigma (a : A) (f a = b))) (f q.1, in (q.1, idp)) p q.2) },
      sigmaInc (\lam b => Trunc (\Sigma (a : A) (f a = b)))
     )

-- 3. Определение Int.

-- Конструкторы в обычных типах данных не пересекаются.
-- Другими словами, мы всегда можем доказать, что con1 не равен con2.

-- Иногда бывает полезно определять типы данных, в которых это будет не верно.
-- Например, удобно определять целые числа как либо положительное натуральное число, либо отрицательное.
-- При этом, эти два конструктора будут пересекаться, так как положительный ноль совпадает с отрицательным.
-- Чтобы определить такой тип данных, нужно в одном или нескольких конструкторов добавить условия, которые говорят как он будет вычисляться.
-- Синтаксис такой же как и для определения функций при помощи паттерн матчинга.
-- Единственное отличие заключается в том, что не обязательно все случаи должны быть покрыты.
-- Например, мы можем определить как neg вычисляется только на zero, но не на suc.
-- Тогда neg 0 будет вычисляться в pos 0, но neg (suc n) будет уже в нормальной форме как обычный конструктор.
\data Int
  | pos Nat
  | neg (n : Nat) \elim n {
    | 0 => pos 0
  }

-- Когда мы определяем функцию над таким типом данных при помощи паттерн матчинга, система проверяет, что ее значение на эквивалентных конструкторах совпадают.
-- Например, следующее определение не пройдет, так как intEx (pos 0) равно 3, а intEx (neg 0) равно 7.
{-
\func intEx (z : Int) : Nat
  | pos n => 3
  | neg n => 7
-}

-- Паттерны, которые вычисляются, можно пропускать в паттерн матчинге.
-- Например, в следующей функции мы не определили ее значение на neg 0, но система принимает это определение.
\func intEx' (z : Int) : Nat
  | pos n => 3
  | neg (suc n) => 7

-- 4. Фактор-множества.

-- Фактор-множества -- это полезная конструкция над множествами.
-- Если A -- множество с отношением эквивалентности ~ на нем, то мы можем определить новое множество A/~ вместе с функцией in~ : A -> A/~, которая делает равными эквивалентные элементы A.
-- A : \Set
-- ~ : A -> A -> \Prop
-- A/~ : \Set
-- in~ : A -> A/~
-- (in~ a = in~ a') <-> (a ~ a')

-- Чтобы определить функцию над A/~, достаточно задать ее на произвольном элементе a : A так, чтобы эквивалентным элементам соответствовали равные результаты.
-- Мы можем использовать примерно следующий синтаксим, но в нем нет доказательства этого условия.
-- Точный синтаксис приведен ниже.
-- \func f (x : A/~) : B
--   | in~ a => b

-- Пример использвания фактор-множеств -- это рациональные числа, которые определяются как пары целых чисел с точностью до эквивалентности.
-- Rat = (\Sigma Int Int) / ~
-- Где (n,m) ~ (n',m') тогда и только тогда, когда n * m' = n' * m.

-- Фактор-множества можно определить при помощи типов данных с условиями.
-- Мы просто добавляем конструктор с параметром типа I и двумя условиями на него.
\truncated \data Quotient (A : \Type) (R : A -> A -> \Prop) : \Set
  | inR A
  | eq (a a' : A) (R a a') (i : I) \elim i {
    | left => inR a
    | right => inR a'
  }

-- Тогда path (eq a a' r) будет задавать равенство между двумя элементами, указанными в этих условиях.
-- В данном случае мы получаем необходимое равенство между эквивалентными элементами.
\func quotientEq {A : \Type} {R : A -> A -> \Prop} (a a' : A) (r : R a a')
  : inR a = {Quotient A R} inR a'
  => path (eq a a' r)

-- Чтобы определить функцию над Quotient A R, необходимо задать ее на элементе вида inR a и на конструкторе eq,
-- что соответствует доказательству того, что эквивалентным элементам соответствуют равные значения.
\func quotientEx {A : \Type} {R : A -> A -> \Prop} {B : \Set} (f : A -> B) (p : \Pi (a a' : A) -> R a a' -> f a = f a') (x : Quotient A R) : B \elim x
  | inR a => f a
  | eq a a' r i => p a a' r @ i
